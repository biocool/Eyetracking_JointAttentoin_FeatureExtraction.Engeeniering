---
title: "Joint Attention Feature Extraction"
output: html_notebook
---

## libraries
```{r libs}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(skimr)
library(stringr)

```


# Function Definition


##Preprocessing functoin and feature extraction

```{r Preprocessing and feature extraction functoin definition}
################################################################################
#Description=======
#This function gets a dataframe of contining the relevant columns for TAOIs and returns the looking patterns for all TAOIs
################################################################################
#INPUT====
#"ja.df.all.Cols": a df of joint attentoin data (having just the relevant columns)
################################################################################
#OUTPUT====
#"looking.pattern.sequence.list": a list of looking patterns for all TAOIs
#each element of the looking.pattern.sequence.list is a vector 
#the sequence in each vector has the following pattern
#"None", "A1", "start.time", "end.time", "duration", "A2", "start.time", "end.time", "duration", "A3", "start.time", "end.time", "duration"....
#"Ai" is the ith area that has been looking at by the subject (it can be: "TAOI", "Face", "Hand", or "Other")
################################################################################
#NOTE=====
#some variables like "TAOI.Detail.4.Input", "TAOI.Target.ColName.Vctr", "TAOI.Hand.ColName.Vctr", "TAOI.Face.ColName.Vctr" are supposed to be Global variables
################################################################################
#function definition========
ja.Preprocessing.and.FeatureExtraction <- function(ja.df.all.Cols)
{
 #extracting the col index for the three types of area:Target, Hand, Face==========
  
TAOI.Target.Col.Indx <-
  which(colnames(ja.df.all.Cols) %in% TAOI.Target.ColName.Vctr)

TAOI.Hand.Col.Indx <-
  which(colnames(ja.df.all.Cols) %in% TAOI.Hand.ColName.Vctr)

TAOI.Face.Col.Indx <-
  which(colnames(ja.df.all.Cols) %in% TAOI.Face.ColName.Vctr)

################################################################################
#Preprocessing
################################################################################
#time offset calculation and replacing "-1"=======

#the below index shows the first row of the file that has non.NA value for the "AOI.hit..BA.Joint.Attention.04.12.2019...01_HiSweetie_Target_Face."
#which should be the first AOI that would be activated. 
#and it should be the first row that TOBII showed the video and so we can set that as the time = 0
timestamp.offset.index <- 
  min(which(!is.na(ja.df.all.Cols$AOI.hit..BA.Joint.Attention.04.12.2019...01_HiSweetie_Target_Face.)))
#View(ja.df.all.Cols)
#dim(ja.df.all.Cols)

#this value should be used to substract from the "Recording.timestamp" to show the actual one 
my.time.offset <- 
  ja.df.all.Cols$Recording.timestamp[timestamp.offset.index]
#selecting the rows after frist activation (the rows before that are not useful)
ja.df.all.Cols <- 
  ja.df.all.Cols[c(timestamp.offset.index:nrow(ja.df.all.Cols)),]

#applying the offset to the timestamp 
ja.df.all.Cols$Corrected.Recording.timestamp <-
  (ja.df.all.Cols$Recording.timestamp - my.time.offset)

#View(ja.df.all.Cols$AOI.hit..BA.Joint.Attention.04.12.2019...01_HiSweetie_Target_Teddy.)

#replacing "-1"
#in the original file "-1" means inactive for each AOI ("0" means active but not being looked at; "1" means active and being looked at). However for having simpler analysis I'm gonna replace "-1" with 5
# 5 means inactive
ja.df.all.Cols[ja.df.all.Cols == -1] <- 5

#Manually adding new cols for  TAOI.Hand.Face.Sum and TAOI.Final.Hand.Face.Logical======

##Adding new empty cols 
ja.df.all.Cols$TAOI.Hand.Face.Sum1 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum2 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum3 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum4 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum5 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum6 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum7 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum8 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum9 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum10 <- "NA"
ja.df.all.Cols$TAOI.Hand.Face.Sum11 <- "NA"

TAOI.Hand.Face.Sum.ColName.Vctr<- 
  c("TAOI.Hand.Face.Sum1",
  "TAOI.Hand.Face.Sum2",
  "TAOI.Hand.Face.Sum3",
  "TAOI.Hand.Face.Sum4",
  "TAOI.Hand.Face.Sum5",
  "TAOI.Hand.Face.Sum6",
  "TAOI.Hand.Face.Sum7",
  "TAOI.Hand.Face.Sum8",
  "TAOI.Hand.Face.Sum9",
  "TAOI.Hand.Face.Sum10",
  "TAOI.Hand.Face.Sum11")

ja.df.all.Cols$TAOI.Final.Hand.Face.Logical1<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical2<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical3<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical4<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical5<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical6<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical7<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical8<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical9<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical10<- "NA"
ja.df.all.Cols$TAOI.Final.Hand.Face.Logical11<- "NA"


TAOI.Final.Hand.Face.Logical.ColName.Vctr<- 
  c("TAOI.Final.Hand.Face.Logical1",
  "TAOI.Final.Hand.Face.Logical2",
  "TAOI.Final.Hand.Face.Logical3",
  "TAOI.Final.Hand.Face.Logical4",
  "TAOI.Final.Hand.Face.Logical5",
  "TAOI.Final.Hand.Face.Logical6",
  "TAOI.Final.Hand.Face.Logical7",
  "TAOI.Final.Hand.Face.Logical8",
  "TAOI.Final.Hand.Face.Logical9",
  "TAOI.Final.Hand.Face.Logical10",
  "TAOI.Final.Hand.Face.Logical11")

#extracting the col index vectors
TAOI.Hand.Face.Sum.Col.Indx <-
  which(colnames(ja.df.all.Cols) %in% TAOI.Hand.Face.Sum.ColName.Vctr)

TAOI.Final.Hand.Face.Logical.Col.Indx <-
  which(colnames(ja.df.all.Cols) %in% TAOI.Final.Hand.Face.Logical.ColName.Vctr)

#calculating values for TAOI.Hand.Face.Sum and TAOI.Final.Hand.Face.Logical====
#adding hand face inetgrated col============
#one of the most important feature is the number of times that fixation was moved from/to TAOI to/from hand/face.
#So, I,m gonna add a new col that shows hand or face was hitted. 
#NOTE: for some TAOI hand was not defined (for example hands was in the TAOI or wasn't visible)
#adding hand face inetgrated col for each element of the "TAOI.Target.ColName.Vctr"
#each new col. shows whether hand or face was hitted or not 

#I'm gonna add new col. which is the sum of the face and hand 
#Based on the different values for sum we can infer whether face/hand was hitted or not:
#1 or 6 means face/hand was hitted (1: one was hitted and the other one was activ; 6:one was hitted and the other one was inactiv)
for (i in c(1:No.of.TAOI)) 
{
  ja.df.all.Cols[,TAOI.Hand.Face.Sum.Col.Indx[i]] <- 
    ja.df.all.Cols[,TAOI.Face.Col.Indx[i]] + ja.df.all.Cols[,TAOI.Hand.Col.Indx[i]]

  ja.df.all.Cols[,TAOI.Final.Hand.Face.Logical.Col.Indx[i]] <- 
  ((ja.df.all.Cols[,TAOI.Hand.Face.Sum.Col.Indx[i]] == 1) | (ja.df.all.Cols[,TAOI.Hand.Face.Sum.Col.Indx[i]] == 6))

}

#I noticed that different projects has different number of columns
#so I'm gonna use "Whole_Scene" to find that last column that should be used 

last.inofrmative.col.indx <- 
  max(which(!is.na(str_match(string = colnames(ja.df.all.Cols), pattern = "Whole_Scene"))))
#browser()
#all column names that are related to AOIs stasrt with "AOI hit"
first.inofrmative.col.indx <- 
  min(which(!is.na(str_match(string = colnames(ja.df.all.Cols), pattern = "AOI.hit"))))

ja.df.all.AOI.hitted.logical <- (ja.df.all.Cols[,c(first.inofrmative.col.indx:last.inofrmative.col.indx)]==1)
#dim(ja.df.all.AOI.hitted.logical)

##the below vector is a numeric vector in which if an entry equals to "0" then it means that at the corresponding time the subject was blinking OR not looking.at.the.display
blinking.OR.not.at.the.display <- 
  rowSums(ja.df.all.AOI.hitted.logical)
length(blinking.OR.not.at.the.display)

ja.df.all.Cols <- 
  ja.df.all.Cols %>% #Defining blinking.not.at.the.display for all TAOIs
  mutate(blinking.OR.not.at.the.display.Logical = (blinking.OR.not.at.the.display == 0 ))


#Adding "Other" cols=========
#Adding new columns, corresponds to each TAOI, to be considered as "Other". For each TAOI, this column shows whether none of the face/hand and TAOI was being looked at or not

ja.df.all.Cols$TAOI.Other.Logical1 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical2 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical3 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical4 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical5 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical6 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical7 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical8 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical9 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical10 <- "NA"
ja.df.all.Cols$TAOI.Other.Logical11 <- "NA"


TAOI.Other.Logical.ColName.Vctr<- 
  c("TAOI.Other.Logical1",
  "TAOI.Other.Logical2",
  "TAOI.Other.Logical3",
  "TAOI.Other.Logical4",
  "TAOI.Other.Logical5",
  "TAOI.Other.Logical6",
  "TAOI.Other.Logical7",
  "TAOI.Other.Logical8",
  "TAOI.Other.Logical9",
  "TAOI.Other.Logical10",
  "TAOI.Other.Logical11")

#extracting the col index vectors for "Other"
TAOI.Other.Logical.Col.Indx <-
  which(colnames(ja.df.all.Cols) %in% TAOI.Other.Logical.ColName.Vctr)



for (i in c(1:No.of.TAOI)) 
{
  ja.df.all.Cols[,TAOI.Other.Logical.Col.Indx[i]] <- !(ja.df.all.Cols[,TAOI.Final.Hand.Face.Logical.Col.Indx[i]] | 
    (ja.df.all.Cols[,TAOI.Target.Col.Indx[i]] == 1))&(!ja.df.all.Cols$blinking.OR.not.at.the.display.Logical)
}

#Selecting the final subset of cols======
#selecting only features that we need in addition to the time stamp
blinking.OR.not.at.the.display.indx <- 
  which(colnames(ja.df.all.Cols) == "blinking.OR.not.at.the.display.Logical") 


ja.df.AOIs.Cols <- 
  ja.df.all.Cols

#the following list contains the [start, end] time intervals for each TAOI (time is in ms.)
#I got this intervals from Charlene in a csv file
#each element of this list will be used to subset the original data frame 
#So, the below list shoud be initialized manually
time.inetrval.TAOI.list <- list(
  TAOI1.Time.Interval = c(TAOI.Detail.4.Input$StartTime[1], TAOI.Detail.4.Input$EndTime[1]), 
  TAOI2.Time.Interval = c(TAOI.Detail.4.Input$StartTime[2], TAOI.Detail.4.Input$EndTime[2]),
  TAOI3.Time.Interval = c(TAOI.Detail.4.Input$StartTime[3], TAOI.Detail.4.Input$EndTime[3]),
  TAOI4.Time.Interval = c(TAOI.Detail.4.Input$StartTime[4], TAOI.Detail.4.Input$EndTime[4]),
  TAOI5.Time.Interval = c(TAOI.Detail.4.Input$StartTime[5], TAOI.Detail.4.Input$EndTime[5]),
  TAOI6.Time.Interval = c(TAOI.Detail.4.Input$StartTime[6], TAOI.Detail.4.Input$EndTime[6]),
   TAOI7.Time.Interval = c(TAOI.Detail.4.Input$StartTime[7], TAOI.Detail.4.Input$EndTime[7])#,
  # TAOI8.Time.Interval = c(TAOI.Detail.4.Input$StartTime[8], TAOI.Detail.4.Input$EndTime[8]),
  # TAOI9.Time.Interval = c(TAOI.Detail.4.Input$StartTime[9], TAOI.Detail.4.Input$EndTime[9]),
  # TAOI10.Time.Interval = c(TAOI.Detail.4.Input$StartTime[10], TAOI.Detail.4.Input$EndTime[10]),
  # TAOI11.Time.Interval = c(TAOI.Detail.4.Input$StartTime[11], TAOI.Detail.4.Input$EndTime[11])
  )


################################################################################
#Feature Extraction
################################################################################
#initialization=====
#this list will contain the sequence of the looking pattern. So, it would be in this format: c("None, "Hand/Face", "Face", "TAOI", "Other", ....)

looking.pattern.sequence.list <- 
  list(TAOI1.looking.pattern.sequence = c("None"), 
       TAOI2.looking.pattern.sequence  = c("None"),
       TAOI3.looking.pattern.sequence = c("None"),
       TAOI4.looking.pattern.sequence  = c("None"),
       TAOI5.looking.pattern.sequence  = c("None"),
       TAOI6.looking.pattern.sequence  = c("None"),
       TAOI7.looking.pattern.sequence  = c("None")#,
       # TAOI8.looking.pattern.sequence  = c("None"),
       # TAOI9.looking.pattern.sequence  = c("None"),
       # TAOI10.looking.pattern.sequence  = c("None"),
       # TAOI11.looking.pattern.sequence  = c("None")
       )
#for each AOI we need a "no.of.gaze.shifts"
no.of.gaze.shifts.vctr[i] <- 
  rep(0, length(looking.pattern.sequence.list))
  
#View(ja.df.AOIs.Cols)
#Main loop===========
#in this loop index i shows the index of the AOI that would be processed
for (i in c(1:No.of.TAOI)) 
{
  # #print("========================================")
  # #print("========================================")
  # #print("========================================")
  # #print(i)
  # my.time.offset
  #loop body ========
  #selecting a subset of the original df that is correspond to the time frame of TAOI
  #Note: the "Corrected.Recording.timestamp" is the corrected time by substracting "my.time.offset", which is the offset time for the current subject, from the tobbi's original "Recording.timestamp"

  
  ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI <-   
        subset(ja.df.AOIs.Cols, (Corrected.Recording.timestamp >= time.inetrval.TAOI.list[[i]][1]) & 
                 (Corrected.Recording.timestamp <= time.inetrval.TAOI.list[[i]][2]))
  #REMOVE
  #View(ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI)
  #dim(ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI)

  #this shows the first time that the TAOI was hitted #TAOI.Target.Col.Indx[i] is the column's name in the original data 
  #that is correpsond to the TAOI.Target.Col.Indx[i]
  #this shows the first time the corresponding face/hand was hitted (It is not the actual time but is the row index)

  time.point.first.target.hit <- 
    min(which(ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[, TAOI.Target.Col.Indx[i]] == 1)) #TAOI.Target.Col.Indx[i] shows the column in the original data 
  
  #fidning the first hit of the Face/Hand 
  #TAOI.Final.Hand.Face.Logical.Col.Indx[i] is the column's name in the original data 
  #that is correpsond to the TAOI.Final.Hand.Face.Logical.Col.Indx[i]
  #this shows the first time the corresponding face/hand was hitted (It is not the actual time but is the row index)
  time.point.first.hand.face.hit <- 
    min(which(ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[, TAOI.Final.Hand.Face.Logical.Col.Indx[i]] ==TRUE))
  #if face/hand was hitted earlier than targe then we add 1 to no.of.gaze.shifts.vctr[i] 
  #==>fianlly we can consider time.point.first.hand.face.hit == 1 as 0 (becuase it means that in fact target was not hitted OR after hitting there were not gaze shift towards face/hand)

  
  #if subject didn't looked at hand/face or TAOI at all, then update the looking.pattern.sequence.list and skip the analysis for the current subject
  if ((time.point.first.target.hit == Inf) & time.point.first.hand.face.hit == Inf) 
  {
      looking.pattern.sequence.list[[i]] <- 
      cbind(looking.pattern.sequence.list[[i]], "No TAOI/Hand/Face")
      
    next
  }
  #in this while loop we iterate over the all time points 
  time.point.counter <- 
    1
  no.of.time.points <- 
    nrow(ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI)
  #extracting the looking pattern sequence for the current AOI
  while (time.point.counter < no.of.time.points) 
  {
    #the below time will be used for each value of looking  pattern sequence to compute the time duration 
    #Note: the "Corrected.Recording.timestamp" is the corrected time by substracting "my.time.offset", which is the offset time for the current subject, from the tobbi's original "Recording.timestamp"
    .start.time <- 
      ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter,"Corrected.Recording.timestamp"]
    
    #browser()
    #there are four mutually exclusive "if" corresponds to one of the four differenet possible situations: 1-TAOI 2-Face/Hand 3-Other 4- blinking.OR.not.at.the.display
    #====================================================================================================================================================================
    #if TAOI was hitted then increase the "no.of.gaze.shifts.vctr[i]" AND find the first time point that TAOI wasn't hitted
    if(ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, TAOI.Target.Col.Indx[i]]  ==  1) 
    {
      #print(time.point.counter)
      #print("TAOI")
      no.of.gaze.shifts.vctr[i] <- no.of.gaze.shifts.vctr[i] + 1
      looking.pattern.sequence.list[[i]] <- 
        cbind(looking.pattern.sequence.list[[i]], "TAOI")
      #while target is being looked at
      #Optimize flag (use min + which)
      while ( ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, TAOI.Target.Col.Indx[i]]  ==  1) 
      {
        time.point.counter <- time.point.counter + 1
        #check for the "out of range" index
        if (time.point.counter >= no.of.time.points)
        {
          break
        }
      }
      .end.time <- 
        ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter,"Corrected.Recording.timestamp"]
      .time.duration <- 
        .end.time - .start.time
      #Adding start, end and duration of the looking time for the current value of the looking.pattern.sequence
      #numbers in the pranthesis are the the corresponding Tobii's time stamps 
      #"looking.pattern.sequence.list[[i]]" is a vector of "looking area name" (TAOI/HANFace/Other/None/Blinking...) and their details (including: corrected starttime stamp (relative),  original start time stamp start.time, corrected end time stamp (relative),  original end time stamp start.time, time.duration)
      looking.pattern.sequence.list[[i]] <- 
        cbind(looking.pattern.sequence.list[[i]], 
              paste("corrected time stamp (relative) start.time",as.character(.start.time), "  original time stamp start.time", as.character((.start.time+my.time.offset)), sep = ";"),
              paste("corrected time stamp (relative) end.time",as.character(.end.time), "  original time stamp end.time", as.character((.end.time+my.time.offset)), sep = ";"),
              as.character(.time.duration))
      next

    } 
    #====================================================================================================================================================================
    #if hand/face was hitted then increase the "no.of.gaze.shifts.vctr[i]" AND find the first time point that hand/face wasn't hitted
    if (ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, 
                                                      TAOI.Final.Hand.Face.Logical.Col.Indx[i]] == TRUE) 
    {
      if (ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, 
                                                        TAOI.Face.Col.Indx[i]] == 1) 
      {
        #print(time.point.counter)
        #print("Face")
        
        looking.pattern.sequence.list[[i]] <- 
          cbind(looking.pattern.sequence.list[[i]], "Face")
        
      }else
      {
        looking.pattern.sequence.list[[i]] <- 
          cbind(looking.pattern.sequence.list[[i]], "Hand")
        #print(time.point.counter)
        #print("Hand")
        
      }
      no.of.gaze.shifts.vctr[i] <- no.of.gaze.shifts.vctr[i] + 1 
      while (ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, TAOI.Final.Hand.Face.Logical.Col.Indx[i]] == TRUE) 
      {
        time.point.counter <- time.point.counter + 1
        if (time.point.counter >= no.of.time.points)
        {
          break
        }
      }
      .end.time <- 
        ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter,"Corrected.Recording.timestamp"]
      .time.duration <- 
        .end.time - .start.time
      looking.pattern.sequence.list[[i]] <- 
        cbind(looking.pattern.sequence.list[[i]], 
              paste("corrected time stamp (relative) start.time",as.character(.start.time), "original time stamp start.time", as.character((.start.time+my.time.offset)), sep = ";"),
              paste("corrected time stamp (relative) end.time",as.character(.end.time), "original time stamp end.time", as.character((.end.time+my.time.offset)), sep = ";"),
              as.character(.time.duration))
      next
      
    }
    #====================================================================================================================================================================
    #if one of the other AOI was hitted then increase the "no.of.gaze.shifts.vctr[i]" AND find the first time point that "the other AOI" wasn't hitted

 
    if (ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, 
                                                      TAOI.Other.Logical.Col.Indx[i]] == TRUE) 
    {
      #print(time.point.counter)
      #print("Other")
      looking.pattern.sequence.list[[i]] <- cbind(looking.pattern.sequence.list[[i]], "Other")
      no.of.gaze.shifts.vctr[i] <- no.of.gaze.shifts.vctr[i] + 1 
      while (ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, 
                                                            TAOI.Other.Logical.Col.Indx[i]] == TRUE) 
      {
        time.point.counter <- time.point.counter + 1
        if (time.point.counter >= no.of.time.points)
        {
          break
        }
      }
      .end.time <- 
        ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter,"Corrected.Recording.timestamp"]
      .time.duration <- 
        .end.time - .start.time
      looking.pattern.sequence.list[[i]] <- 
        cbind(looking.pattern.sequence.list[[i]],
              paste("corrected time stamp (relative) start.time",as.character(.start.time), "original time stamp start.time", as.character((.start.time+my.time.offset)), sep = ";"),
              paste("corrected time stamp (relative) end.time",as.character(.end.time), "original time stamp end.time", as.character((.end.time+my.time.offset)), sep = ";"),
              as.character(.time.duration))
      next
    }
    #====================================================================================================================================================================
    #if one of the other AOI was hitted then increase the "no.of.gaze.shifts.vctr[i]" AND find the first time point that "the other AOI" wasn't hitted
    if (ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, 
                                                       blinking.OR.not.at.the.display.Logical.name] == TRUE) 
    {
      #print(time.point.counter)
      #print("blinking.OR.not.at.the.display")
      looking.pattern.sequence.list[[i]] <- 
        cbind(looking.pattern.sequence.list[[i]], "blinking.OR.not.looking.at.the.display")
      no.of.gaze.shifts.vctr[i] <- no.of.gaze.shifts.vctr[i] + 1 
      while (ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter, 
                                                            blinking.OR.not.at.the.display.Logical.name] == TRUE) 
      {
        time.point.counter <- time.point.counter + 1
        if (time.point.counter >= no.of.time.points)
        {
          break
        }
      }
      .end.time <- 
        ja.df.AOIs.Cols.Subset.Correspnd.2.CurrentTAOI[time.point.counter,"Corrected.Recording.timestamp"]
      .time.duration <- 
        .end.time - .start.time
      looking.pattern.sequence.list[[i]] <- 
        cbind(looking.pattern.sequence.list[[i]], 
              paste("corrected time stamp (relative) start.time",as.character(.start.time), "original time stamp start.time", as.character((.start.time+my.time.offset)), sep = ";"),
              paste("corrected time stamp (relative) end.time",as.character(.end.time), "original time stamp end.time", as.character((.end.time+my.time.offset)), sep = ";"),
              as.character(.time.duration))
      next
    }
    #====================================================================================================================================================================
    
    #just to avoid an infinitive loop if none of the TAOI and hand/face was looking at
    time.point.counter <- time.point.counter + 1
  }
}
  
#each element of the looking.pattern.sequence.list is a vector 
#the sequence in each vector has the following pattern
#"None", "A1", "start.time", "end.time", "duration", "A2", "start.time", "end.time", "duration", "A3", "start.time", "end.time", "duration"....
#"Ai" is the ith area that has been looking at by the subject (it can be: "TAOI", "Face", "Hand", or "Other")


return(looking.pattern.sequence.list)

}#main functoin 
  
```


##Writing fuction

```{r writing the looking pattern sequence into csv files }
write.JA.lookingPatterns2HDD <- function(looking.pattern.sequence.list,
                                         filenames.full.path)

{
  #preparing the final df as to be written as a csv file========
  #preparing a df for final data in the new format 
  
  #I'm assuming that the maximum number of looking seq. length is 200, so nrow = 200
  #for each TAOI we need six different values looking.area;start.time.relative;start.time.original;end.time.relative;end.time.original;duration
  final.csv.features.df <- matrix(nrow = 200, ncol = No.of.TAOI*6)
  final.csv.features.df <- 
    as.data.frame(final.csv.features.df)
  #assiging appropriate colnames===== 
  common.col.names.4.all.TAOI.Target.vctr <- 
    c("looking.area",
      "start.time.relative", "start.time.original", 
      "end.time.relative", "end.time.original",
      "duration")
  col.names.4.all.TAOI.Target.vctr <- c()
  for (current.TAOI.Target.Name in TAOI.Target.ColName.Vctr) 
  {
    #adding the common.col.names.4.all.TAOI.Target.vctr (which are common columns for all TAOIs) to the end of the current.TAOI.Target.Name to make unique meqaningful names for those features
   col.names.4.current.TAOI.Target.vct <-
      paste(current.TAOI.Target.Name, common.col.names.4.all.TAOI.Target.vctr, sep = "")
   col.names.4.all.TAOI.Target.vctr <-
     c(col.names.4.all.TAOI.Target.vctr, col.names.4.current.TAOI.Target.vct)
  }
  
  #sanity check
  #length(col.names.4.all.TAOI.Target.vctr) == ncol(final.csv.features.df)#TRUE
  colnames(final.csv.features.df) <- 
    col.names.4.all.TAOI.Target.vctr
  
  #writing the data in the final.csv.df======
  
  for (i in c(1:No.of.TAOI)) 
  {
    #each element of the "looking.pattern.sequence.list[[i]]" is vector of looking pattern sequence for a TAOI.
  #the name of that TAOI is "TAOI.Target.ColName.Vctr[i]"
  #if "length(looking.pattern.sequence.list[[i]]) == 2" then the subject didn't look at the TAOI
  #else: 
  ## j = 2,6,10,...<==>seq(2,length(looking.pattern.sequence.list[[i]]),4)
  ## "looking.pattern.sequence.list[[i]][j]" is the area that was hitted (hand/face/taoi/other/blinking)
  ## "looking.pattern.sequence.list[[i]][j+1]" is in this format: "corrected time stamp (relative) start.time;17267;original time stamp start.time;31790"
  ## So, after spliting "looking.pattern.sequence.list[[i]][j+1]" using ";" as delim. the second and forth elements are relative and original start time, respectively.
  ## "looking.pattern.sequence.list[[i]][j+2]" is in this format: "corrected time stamp (relative) end.time;17280;original time stamp end.time;31803"
  ## So, after spliting "looking.pattern.sequence.list[[i]][j+2]" using ";" as delim. the second and forth  elements is relative and original end time, respectively.
   ##"looking.pattern.sequence.list[[i]][j+3]" is the duration time
    for (j in (seq(2,length(looking.pattern.sequence.list[[i]]),4))) 
    {
      row.indx <- 
        ceiling(j/4)#ceiling(j/4) shows the current row number for the ith TAOI 
      #col indices for corrent looking area are (i-1)*6 + 1 ...i*6
      first.col.indx <- (i-1)*6 + 1
      last.col.indx <- i*6 
      col.indx.vctr <- c(first.col.indx:last.col.indx)
      if (length(looking.pattern.sequence.list[[i]]) == 2)#the subject didn't look at the TAOI
      {
        final.csv.features.df[row.indx, col.indx.vctr[1]] <-
          "None"
        final.csv.features.df[row.indx, col.indx.vctr[2]] <-
          -1
        final.csv.features.df[row.indx, col.indx.vctr[3]] <-
          -1
        final.csv.features.df[row.indx, col.indx.vctr[4]] <-
          -1
        final.csv.features.df[row.indx, col.indx.vctr[5]] <-
          -1
        final.csv.features.df[row.indx, col.indx.vctr[6]] <-
          -1
      }else
      {
        start.time.details.vctr <- 
        strsplit(x = looking.pattern.sequence.list[[i]][j+1], split = ";", fixed = TRUE)
        end.time.details.vctr <- 
        strsplit(x = looking.pattern.sequence.list[[i]][j+2], split = ";", fixed = TRUE)
        
        final.csv.features.df[row.indx, col.indx.vctr[1]] <-
          looking.pattern.sequence.list[[i]][j]#Looking area
        final.csv.features.df[row.indx, col.indx.vctr[2]] <-
          as.numeric(start.time.details.vctr[[1]][2])
        final.csv.features.df[row.indx, col.indx.vctr[3]] <-
          as.numeric(start.time.details.vctr[[1]][4])
        final.csv.features.df[row.indx, col.indx.vctr[4]] <-
          as.numeric(end.time.details.vctr[[1]][2])
        final.csv.features.df[row.indx, col.indx.vctr[5]] <-
           as.numeric(end.time.details.vctr[[1]][4])
        final.csv.features.df[row.indx, col.indx.vctr[6]] <-
          as.numeric(looking.pattern.sequence.list[[i]][j+3])#duration
      }
    }
    
  }
  filenames.full.path <- 
    paste(filenames.full.path, ".final.csv.features.df.csv", sep = "")
  write.csv(final.csv.features.df,
            file = filenames.full.path)
  

}#write fuction

```




```{r Reading files and applying main functions on them.}
#NOTE: "filenames.full.path.list" is a global variable
driver.fun <- function()
  {
 
  No.of.TAOI <- 7
#total number of subjects (which is the total number of files in the folder)
no.of.JA.files <-
  length(filenames.full.path.list)

#The below df contains six features (looking.area,	 start.time.relative,	 start.time.original	 end.time.relative,	 end.time.original, and	 duration) for each TAOI for all subjects (after merging "other" and "blinking" with <=100ms duration).
#The first column would be the subject ID and the rest are correspond to the features. So the total number of columns would be "6*No.of.TAOI + 1"

#each subject would have 200 rows, so I'm gonna do rbind to add data for each subject to this final df.
final.features.merged.df.4.all.subjects <-
  as.data.frame(matrix(nrow = 1, 
                       ncol = 6*No.of.TAOI + 1))

colnames(final.features.merged.df.4.all.subjects)<- 
  colnames(final.csv.features.merged.4.this.sbj)


#The below df contains the number of full and partial JA circles for all subjects.
#the first column would be the subject ID and the rest are correspond to number of full/partial JA circles. So the total number of columns would be "2*No.of.TAOI + 1"
ja.full.partial.cricle.count.df.4.all.subjects <-
  as.data.frame(matrix(nrow = no.of.JA.files, 
                       ncol = 2*No.of.TAOI + 1))

loop.index <- 0
#browser() 
for (filenames.full.path in filenames.full.path.list) 
{
  #browser() 
  
  loop.index <- 
    loop.index + 1
  #extracting the subject ID
  SubjectID <- 
    str_sub(filenames.list[[loop.index]],1,5)
  #print(">>>><<<< >>>><<<< >>>><<<< >>>><<<< >>>><<<< >>>><<<<")
  #print(paste(loop.index, " from ", no.of.JA.files))
  #print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
  final.csv.features.4.this.sbj <- 
    read.csv(file = filenames.full.path, row.names = 1)
  final.csv.features.merged.4.this.sbj <- 
    ja.merge.Other.and.Blinking.less.than.100.ms.(final.csv.features = final.csv.features.4.this.sbj, subjectID = SubjectID)

  final.features.merged.df.4.all.subjects <-
    rbind(final.features.merged.df.4.all.subjects , 
          final.csv.features.merged.4.this.sbj)
  #in calling "ja.full.partial.cricle.count" we should drop the first column
  #beacuse it's subject ID and in "ja.full.partial.cricle.count" function the first column is the looking area for the first TAOI
  ja.full.partial.cricle.count.df.4.current.sbj <- 
    ja.full.partial.cricle.count(final.csv.features.merged = final.csv.features.merged.4.this.sbj[,-1], 
                              No.of.TAOI = No.of.TAOI)
 #assigning subject ID for this subject
 ja.full.partial.cricle.count.df.4.current.sbj$SubjectID <- 
    SubjectID
 #adding to the final df 
 ja.full.partial.cricle.count.df.4.all.subjects[loop.index,] <-
   ja.full.partial.cricle.count.df.4.current.sbj
}

#assigning the appropirate col names to the two final dfs
colnames(final.features.merged.df.4.all.subjects) <- 
  colnames(final.csv.features.merged.4.this.sbj)
colnames(ja.full.partial.cricle.count.df.4.all.subjects) <- 
  (colnames(ja.full.partial.cricle.count.df.4.current.sbj))
#removing the first NA row
final.features.merged.df.4.all.subjects <-
  final.features.merged.df.4.all.subjects[-1,]



#writing dfs to HDD=====

file.name <- paste(CricleCounts.folder.path, "final.features.merged.df.4.all.subjects.csv", sep = "")
write.csv(final.features.merged.df.4.all.subjects, file = file.name)


file.name <- paste(CricleCounts.folder.path, "ja.full.partial.cricle.count.df.4.all.subjects.csv", sep = "")
write.csv(ja.full.partial.cricle.count.df.4.all.subjects, file = file.name)
  


}
```

Merging the "other" and "blinking.OR.not.looking.at.the.display" with less than 100ms. with the previous lokking area

```{r mergeing function defenition}
#INPUT: "final.csv.features" a df that is the output of "ja.Preprocessing.and.FeatureExtraction" which was processed using "write.JA.lookingPatterns2HDD" function. "subjectID": subject ID which is usally the first 5 characters of the file name. 
#OUTPUT: "final.csv.features.merged" the same df that "other" and "blinking.OR.not.looking.at.the.display" with less than 100ms were merged.
ja.merge.Other.and.Blinking.less.than.100.ms. <- function(final.csv.features, subjectID)
{
    #merging "other" and "blinking.OR.not.looking.at.the.display"====
  #below df is a sample df generated in the JA.FeatExtraction.Rmd
  dim(final.csv.features)
  #View(final.csv.features)
  #for each TAOI, we have six different cols: 
  #"looking.area",
  #    "start.time.relative", "start.time.original", 
  #    "end.time.relative", "end.time.original",
  #    "duration"
  #View(final.csv.features)
  
  #Renaming the name of area to make it more simple=====
  final.csv.features[final.csv.features == "Other"] <- 
    "O"
  final.csv.features[final.csv.features == "blinking.OR.not.looking.at.the.display"] <- 
    "B"
  final.csv.features[final.csv.features == "Hand"] <- 
    "H"
  final.csv.features[final.csv.features == "Face"] <- 
    "F"
  final.csv.features[final.csv.features == "TAOI"] <- 
    "T"
  
  for (TAOI.No in c(1:No.of.TAOI)) 
  {
    
    TOA.col.index <-  
      (TAOI.No - 1 ) * 6 + 1 
    No.of.Partial.JA.Circle <- 0 
    No.of.Full.JA.Circle <- 0 
    #browser()
    if (final.csv.features[1,TOA.col.index] == -1) #this TAOI was not hitted
    {
      next()
    }
    
    #calculating the number of rows that we have in the corresponding column for the current TAOI
    no.of.rows <- 
      length(na.omit(final.csv.features[,TOA.col.index]))
    
    #in this loop I'm going to count the "No.of.Partial.JA.Circle" 
    #and "No.of.Full.JA.Circle"
    #So, in each iteration; I should check the three last areas that were hitted
    
    current.row.index <- 2
    while (current.row.index <= (no.of.rows) ) 
    {
      prev.hitted.area <- 
        final.csv.features[(current.row.index - 1),TOA.col.index]
      current.hitted.area <- 
        final.csv.features[current.row.index ,TOA.col.index]
      current.hitted.area.duration <- 
        final.csv.features[current.row.index,TOA.col.index+5]
      
      #if there two consecutive hitted area with the same name (it could happen if in the previous iterations merge happened)
      #Then the two corresponding rwos shold be merged
      should.merge.with.prev.beacuse.the.same.area <- 
        (prev.hitted.area == current.hitted.area)
      
     if (should.merge.with.prev.beacuse.the.same.area) 
      {
        #adding the duration time to the prev. duration time
        final.csv.features[current.row.index - 1,TOA.col.index + 5] <-
          final.csv.features[current.row.index - 1,TOA.col.index + 5] + current.hitted.area.duration
        
        #shifting the rest of the df one row up (just that part of the df that is correspond to the current TAOI)
        final.csv.features[c((current.row.index):(no.of.rows)),c(TOA.col.index : (TOA.col.index + 5))] <- 
          final.csv.features[c((current.row.index+1):(no.of.rows+1)),c(TOA.col.index : (TOA.col.index + 5))]
        #becuse of shifiting the number of non.NA rows decreased by one!
        no.of.rows <-
          no.of.rows - 1
        #because we moved the rows, we shouldn't change the current.row.index. 
        #Now current.row.index shows a new row 
        next()
      }
      #browser()
       #check the merging criteri
      should.merge.with.prev.beacuse.of.short.blinkingORothers <- 
        (current.hitted.area %in% c("B", "O")) & current.hitted.area.duration <= 100
  
      if (should.merge.with.prev.beacuse.of.short.blinkingORothers) 
      {
        #adding the duration time to the prev. duration time
        final.csv.features[current.row.index - 1,TOA.col.index + 5] <-
          final.csv.features[current.row.index - 1,TOA.col.index + 5] + current.hitted.area.duration
        
        #shifting the rest of the df one row up (just that part of the df that is correspond to the current TAOI)
        final.csv.features[c((current.row.index):(no.of.rows)),c(TOA.col.index : (TOA.col.index + 5))] <- 
          final.csv.features[c((current.row.index+1):(no.of.rows+1)),c(TOA.col.index : (TOA.col.index + 5))]
        #becuse of shifiting the number of non.NA rows decreased by one!
        no.of.rows <-
          no.of.rows - 1
        #because we moved the rows, we shouldn't change the current.row.index. 
        #Now current.row.index shows a new row 
        next()
      }
      #update the current.row.index for the nex iteration
      current.row.index <- current.row.index + 1 
    }
    
  }
  sbj.vctr <- 
    rep(subjectID, nrow(final.csv.features))
  final.csv.features.merged<- 
    cbind(SubjectID= sbj.vctr, final.csv.features)
  return(final.csv.features.merged)
}#function

```



```{r counting full/partial function defenition "}

ja.full.partial.cricle.count <- function(final.csv.features.merged, No.of.TAOI)
{
  
  #the final df for full/partial JA cricles counts
  #for each TAOI we will compute two numbers for full/partial JA cricles counts
  #the first col would be the sbj ID
  #MANUAL!!!
  no.of.subjects <- 1
  subject.NO <- 1
  ja.cricles.counts.df <-  matrix(nrow = no.of.subjects, 
         ncol = (2*No.of.TAOI +1) )
  ja.cricles.counts.df <- 
    as.data.frame(ja.cricles.counts.df)
  #assigning the colnames
  #seq(2,2*No.of.TAOI,2) is the vector corresponding to the even columns that are supposed to have number of full JA cycles
  #seq(3,2*No.of.TAOI+1,2) is the vector corresponding to the even columns that are supposed to have number of partial JA cycles
  colnames(ja.cricles.counts.df)[seq(2,2*No.of.TAOI,2)] <- 
    paste(TAOI.Target.ColName.Vctr, ".No.of.Full.JA.Cycles", sep = "__")
  colnames(ja.cricles.counts.df)[seq(3,2*No.of.TAOI+1,2)]<- 
    paste(TAOI.Target.ColName.Vctr, ".No.of.Partial.JA.Cycles", sep = "__")
  colnames(ja.cricles.counts.df)[1] <- "SubjectID"
  
  
  #in each iteratoin full/partial JA cricles will be calculated for one TAOI
  
  for (TAOI.No in c(1:No.of.TAOI)) 
  {
    #TAOI.No <- 1
    TOA.col.index <-  
      (TAOI.No - 1 ) * 6 + 1 
    No.of.Partial.JA.Circle <- 0 
    No.of.Full.JA.Circle <- 0 
    
    if (final.csv.features.merged[1,TOA.col.index] == -1) #this TAOI was not hitted
    {
      next()
    }
    
    #calculating the number of rows that we have in the corresponding column for the current TAOI
    no.of.rows <- 
      length(na.omit(final.csv.features.merged[,TOA.col.index]))
    
    #in this loop I'm going to count the "No.of.Partial.JA.Circle" 
    #and "No.of.Full.JA.Circle"
    #So, in each iteration; I should check the three last areas that were hitted
  
    current.row.index <- 1
    while (current.row.index <= (no.of.rows -2) ) 
    {
      first.hitted.area <- 
        final.csv.features.merged[current.row.index,TOA.col.index]
      second.hitted.area <- 
        final.csv.features.merged[current.row.index + 1,TOA.col.index]
      third.hitted.area <- 
        final.csv.features.merged[current.row.index + 2,TOA.col.index]
      
      last.three.looking.are.vctr <- 
        c(first.hitted.area, second.hitted.area, third.hitted.area)
  
      is.Full.JA.Circle <- 
        (sum(last.three.looking.are.vctr == c("T","F","T")) == 3) | (sum(last.three.looking.are.vctr == c("F","T","F")) == 3)
        
      #check for full joint attention
      if (is.Full.JA.Circle) 
      {
        No.of.Full.JA.Circle <- 
          No.of.Full.JA.Circle + 1
        #update the current.row.index for the nex iteration
        #the nex circle can start from  current.row.index + 2  (has overlap with the current one)
        current.row.index <- current.row.index + 2 
        next()
      }
      #The same for partial JA cricle======
      is.Partial.JA.Circle <- 
        (sum(last.three.looking.are.vctr == c("H","F","H")) == 3) |
        (sum(last.three.looking.are.vctr == c("H","T","H")) == 3) |  (sum(last.three.looking.are.vctr == c("F","H","F")) == 3) |  (sum(last.three.looking.are.vctr == c("T","H","T")) == 3)
        
      #check for full joint attention
      if (is.Partial.JA.Circle) 
      {
        No.of.Partial.JA.Circle <- 
          No.of.Partial.JA.Circle + 1
        #update the current.row.index for the nex iteration
        #the nex circle can start from  current.row.index + 2  (has overlap with the current one)
        current.row.index <- current.row.index + 2 
        next()
      }
  
      
      
      #update the current.row.index for the nex iteration
      current.row.index <- current.row.index + 1 
    }
    
    #write the JA.Circles
    ja.cricles.counts.df[subject.NO, TAOI.No*2] <- 
      No.of.Full.JA.Circle
    ja.cricles.counts.df[subject.NO, TAOI.No*2+1] <- 
      No.of.Partial.JA.Circle
        
    
  }
return(ja.cricles.counts.df) 
}
```








# Preprocessing

## Loading TAOIs' information


There are 11 TAOIs. However four of theme seem chalenging. 
So, I'm going to work on the rest and then I'll get back to those. 



```{r Reading the TAOI Details from a csv file }
#the below file contains the TAOIs and start and end time stamp in mil. sec. 
load(file = "./Data/TAOI.Detail.4.Input")
#write.csv(TAOI.Detail.4.Input, file = "./Data/TAOI.Detail.4.Input.csv")
#renaming the cols names=======
#in the raw inptu tsv file, col names contain "[", " ", "]", "-" whoich R converts the autamtically to "."
#So, I'm going to do the same replacement to have the sam TAOI names
TAOI.Detail.4.Input$Target.AOI.Names <- 
  gsub(pattern = "[", replacement = ".", x = TAOI.Detail.4.Input$Target.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Target.AOI.Names <- 
  gsub(pattern = " ", replacement = ".", x = TAOI.Detail.4.Input$Target.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Target.AOI.Names <- 
  gsub(pattern = "]", replacement = ".", x = TAOI.Detail.4.Input$Target.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Target.AOI.Names <- 
  gsub(pattern = "-", replacement = ".", x = TAOI.Detail.4.Input$Target.AOI.Names, fixed = TRUE)

#same for Hand.AOI.Names
TAOI.Detail.4.Input$Hand.AOI.Names <- 
  gsub(pattern = "[", replacement = ".", x = TAOI.Detail.4.Input$Hand.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Hand.AOI.Names <- 
  gsub(pattern = " ", replacement = ".", x = TAOI.Detail.4.Input$Hand.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Hand.AOI.Names <- 
  gsub(pattern = "]", replacement = ".", x = TAOI.Detail.4.Input$Hand.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Hand.AOI.Names <- 
  gsub(pattern = "-", replacement = ".", x = TAOI.Detail.4.Input$Hand.AOI.Names, fixed = TRUE)

#same for Face.AOI.Names
TAOI.Detail.4.Input$Face.AOI.Names <- 
  gsub(pattern = "[", replacement = ".", x = TAOI.Detail.4.Input$Face.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Face.AOI.Names <- 
  gsub(pattern = " ", replacement = ".", x = TAOI.Detail.4.Input$Face.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Face.AOI.Names <- 
  gsub(pattern = "]", replacement = ".", x = TAOI.Detail.4.Input$Face.AOI.Names, fixed = TRUE)
TAOI.Detail.4.Input$Face.AOI.Names <- 
  gsub(pattern = "-", replacement = ".", x = TAOI.Detail.4.Input$Face.AOI.Names, fixed = TRUE)

#final name vectors=====
TAOI.Target.ColName.Vctr <- TAOI.Detail.4.Input$Target.AOI.Names
TAOI.Hand.ColName.Vctr <- TAOI.Detail.4.Input$Hand.AOI.Names
TAOI.Face.ColName.Vctr <- TAOI.Detail.4.Input$Face.AOI.Names


#seting No.of.TAOI
No.of.TAOI <- 
  length(TAOI.Target.ColName.Vctr)
```

##Reading all files and looping over them by calling the Main fuction

```{r Getting all file names}

rootFolder <- 
  "./Data/N = 233 Matched ASD TD Delay Exports/233 Matched ASD TD Delay Exports/"
#listing all tsv files in the path (these are raw eye-tracking exports)
##the first 5 character of each element in the below lis show the subject ID
filenames.list <- list.files(rootFolder, pattern="*.tsv")
#file name with full path
filenames.full.path.list <- list.files(rootFolder, pattern="*.tsv", full.names = TRUE)

CricleCounts.folder.path <- 
  "./Data/N = 233 Matched ASD TD Delay Exports/CircleCountRes/"

```

### if all col names are consistent then this part can be discarded
```{r checking the col names}
loop.index <- 0
no.of.JA.files <-
  length(filenames.full.path.list)

col.name.df <- 
  as.data.frame(matrix(nrow = no.of.JA.files, ncol = 300))

for (filenames.full.path in filenames.full.path.list) 
{
  loop.index <- loop.index + 1
  current.JA.df <- 
    read.csv(file = filenames.full.path, sep = "\t", nrows = 100)
   col.name.df[loop.index,1] <- filenames.list[[loop.index]]
   if ("Recording.timestamp..ms."%in%(colnames(current.JA.df))) 
  {
    indx.of.timeStampCol <- 
      which(colnames(current.JA.df)=="Recording.timestamp..ms.")
    colnames(current.JA.df)[indx.of.timeStampCol] <- "Recording.timestamp"
      
  }
  col.name.df[loop.index, c(2:(length(colnames(current.JA.df))+1))] <- 
     colnames(current.JA.df)
  #print(">>>><<<< >>>><<<< >>>><<<< >>>><<<< >>>><<<< >>>><<<<")
  #print(paste(loop.index, " from ", no.of.JA.files))
  #print(dim(current.JA.df))
  #print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
}
write.csv(col.name.df, file = "./Data/col.name.df.csv")

#View(col.name.df)

```

looping over them by calling the Main fuction
```{r Reading files and applying main functions on them}
start.time <- Sys.time()

#just for #printing an appropriate message
loop.index <- 0
no.of.JA.files <-
  length(filenames.full.path.list)
for (filenames.full.path in filenames.full.path.list) 
{
  loop.index <- 
    loop.index + 1
  #print(">>>><<<< >>>><<<< >>>><<<< >>>><<<< >>>><<<< >>>><<<<")
  #print(paste(loop.index, " from ", no.of.JA.files))
  #print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
  current.JA.df <- 
    read.csv(file = filenames.full.path, sep = "\t")
  #In some of the exports like project 15 instead of "Recording.timestamp" we have "Recording.timestamp..ms.". So, I'm goign to replace this colnames to have a consistent colnames. 
  if ("Recording.timestamp..ms."%in%(colnames(current.JA.df))) 
  {
    indx.of.timeStampCol <- 
      which(colnames(current.JA.df)=="Recording.timestamp..ms.")
    colnames(current.JA.df)[indx.of.timeStampCol] <- "Recording.timestamp"
      
  }
  
  looking.pattern.sequence.list.4.current.JA.df <- 
    ja.Preprocessing.and.FeatureExtraction(current.JA.df)
  write.JA.lookingPatterns2HDD(looking.pattern.sequence.list = looking.pattern.sequence.list.4.current.JA.df, filenames.full.path = 
                               filenames.full.path)
}

end.time <- Sys.time()
time.taken <- end.time - start.time
print("Preprocessing time.taken")
```


#POST PROCESSING (CRICLE COUNT) 

##Reading the data

```{r Getting all file names.}
#"check.names=FALSE" allows to have % in the colnames

#listing all csv files in the path
##the first 5 character of each element in the below lis show the subject ID
filenames.list <- list.files(rootFolder, pattern="*.csv")

filenames.full.path.list <- list.files(rootFolder, pattern="*.csv", full.names = TRUE)
```

```{r}
start.time <- Sys.time()
driver.fun()

end.time <- Sys.time()
time.taken <- end.time - start.time
print("Postprocessing time.taken")

```
 



#Notes
1- only "Blinking" and "Other" are merged with the prev. looking area if the duration is <100 m.s.
2- if "Blinking" and "Other" are the first area then those are not merging (because there is no prev. area)



```{r add dxj}
#reading the dxj info
dxj.df.4.JA <- read.csv("/Users/apple/Desktop/Eric/Research/Karen/Classifier/Data/MostUpdated/JointAttentionRawData/JA.FeatureExtraction..R.Proj./Data/NewRawDataExports_06.13.2022/Dxj.csv")
#View(dxj.df.4.JA)
ja.full.partial.cricle.count.4.40.subjects <- read.csv("/Users/apple/Desktop/Eric/Research/Karen/Classifier/Data/MostUpdated/JointAttentionRawData/JA.FeatureExtraction..R.Proj./Data/NewRawDataExports_06.13.2022/All/Subjects.With.ExtractedFeatures/FinalRes/ja.full.partial.cricle.count.df.4.all.subjects.csv", row.names = 1)

dxj.df.4.JA$SubjectID <- 
  toupper(dxj.df.4.JA$SubjectID)
ja.full.partial.cricle.count.4.40.subjects$SubjectID <- 
  toupper(ja.full.partial.cricle.count.4.40.subjects$SubjectID)

ja.full.partial.cricle.count.df.4.all.subjects.with.Dxj <- 
  merge(x = ja.full.partial.cricle.count.4.40.subjects, y = dxj.df.4.JA, by = "SubjectID", all.x = TRUE)
#View(ja.full.partial.cricle.count.df.4.all.subjects.with.Dxj)

length(intersect(ja.full.partial.cricle.count.4.40.subjects$SubjectID, dxj.df.4.JA$SubjectID))

#write.csv(ja.full.partial.cricle.count.df.4.all.subjects.with.Dxj, file = "/Users/apple/Desktop/Eric/Research/Karen/Classifier/Data/MostUpdated/JointAttentionRawData/JA.FeatureExtraction..R.Proj./Data/NewRawDataExports_06.13.2022/All/Subjects.With.ExtractedFeatures/FinalRes/ja.full.partial.cricle.count.df.4.all.subjects.with.Dxj.csv")
#save(ja.full.partial.cricle.count.df.4.all.subjects.with.Dxj, file = "/Users/apple/Desktop/Eric/Research/Karen/Classifier/Data/MostUpdated/JointAttentionRawData/JA.FeatureExtraction..R.Proj./Data/NewRawDataExports_06.13.2022/All/Subjects.With.ExtractedFeatures/FinalRes/ja.full.partial.cricle.count.df.4.all.subjects.with.Dxj")
```






















